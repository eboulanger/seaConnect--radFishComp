setwd("/Users/eboulanger-admin/Documents/project_SEACONNECT/seaConnect--radFishComp/03-RDA/02-Mullus/a-all/")
# load packages
library(adegenet)
library(psych)
library(vegan)
# read in genetic data and extract minor allele frequency matrix
mullus_all <- read.PLINK("mullus_correctid.raw")
mul_m <-as.matrix(mullus_all)
jpeg(filename = "glPlot_mul_all.jpeg", res = 200, width = 1200, height = 1200)
glPlot(mullus_all, posi="topleft") #
dev.off()
# RDA requires complete data frames
sum(is.na(mul_m)) # 330 626 NA's in the matrix
# impute missing values using the most common genotype at each SNP across all individuals
mul.imp <- apply(mul_m, 2, function(x) replace(x, is.na(x), as.numeric(names(which.max(table(x))))))
sum(is.na(mul.imp)) # No NAs
# load environmental data
env <- read.table("../../00-envdata-EB/Mullus_yearly_SST_SSS.txt", sep = "\t", header = T, stringsAsFactors = F)
str(env)
env$Ecoregion <- as.factor(env$Ecoregion)
env$Ecoregion_adj <- as.factor(env$Ecoregion_adj)
# Confirm that genotypes and environmental data are in the same order
identical(rownames(mul.imp), env$ID) # FALSE
temp <- cbind(rownames(mul.imp), env$ID) # order is indeed different
rownames(env) <- env$ID
env <- env[rownames(mul.imp),]
identical(rownames(mul.imp), rownames(env)) #TRUE
# check correlation between predictors
pairs.panels(env[,7:12], scale=T)
# check correlation between predictors
pairs.panels(env[,5:12], scale=T)
jpeg(filename = "mul_RDA_pred_corr.jpeg", res = 200, width = 1200, height = 1200)
pairs.panels(env[,5:12], scale=T)
jpeg(filename = "mul_RDA_pred_corr.jpeg", res = 200, width = 1200, height = 1200)
# check correlation between predictors
# jpeg(filename = "mul_RDA_pred_corr.jpeg", res = 200, width = 1200, height = 1200)
pairs.panels(env[,5:12], scale=T)
dev.off()
# dev.off()
# SST and SSS are highly correlated amongst eachother, of course, but only 60% between eachother -> ok for RDA
# keep only max of each for now
pred <- subset(env, select=c(lat, lon, SST_yearly_max, SSS_yearly_max))
names(pred) <- c("lat", "lon","SST", "SSS")
pairs.panels(pred, scale=T)
mul.rda <- rda(mul.imp ~ ., data=pred, scale=T)
mul.rda
# calculate adjusted Rsquared
RsquareAdj(mul.rda)
# $adj.r.squared
# [1] 0.00437503 -> very very low? 0,4% (wolf vignette: 5%)
# + lat + lon: 0.007944112
# eigenvalues constrained axes
summary(eigenvals(mul.rda, model = "constrained"))
screeplot(mul.rda)
# base
# jpeg(filename = "RDAplot_mul_base.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, scaling=3)          # default is axes 1 and 2
jpeg(filename = "RDAplot_mul2_base.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, scaling=3)
dev.off()
# more informative plot
#levels(env$Ecoregion_adj) <- c("Alboran Sea", "Western Mediterranean", "Central Mediterranean","Adriatic Sea","Aegean Sea","Levantine Sea")
#env$Ecoregion_adj <- factor(env$Ecoregion_adj, levels=c("Alboran Sea", "Western Mediterranean", "Central Mediterranean","Adriatic Sea","Aegean Sea","Levantine Sea")) # set levels order
eco <- env$Ecoregion_adj
bg <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3","#33a02c","#e31a1c") # 6 nice colors for our ecoregions_adj
# axes 1 & 2
# jpeg(filename = "RDAplot_mul_enhanced.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3)
points(mul.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(mul.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[eco]) # the individuals
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(eco), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
jpeg(filename = "RDAplot_mul2_enhanced.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3)
points(mul.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(mul.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[eco]) # the individuals
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(eco), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
dev.off()
# check correlation between predictors
# jpeg(filename = "mul_RDA_pred_corr.jpeg", res = 200, width = 1200, height = 1200)
pairs.panels(env[,7:12], scale=T)
jpeg(filename = "mul_RDA_pred_corr2.jpeg", res = 200, width = 1200, height = 1200)
pairs.panels(env[,7:12], scale=T)
dev.off()
mul.rda <- rda(mul.imp ~ ., data=pred, scale=T)
mul.rda
# more informative plot
#levels(env$Ecoregion_adj) <- c("Alboran Sea", "Western Mediterranean", "Central Mediterranean","Adriatic Sea","Aegean Sea","Levantine Sea")
#env$Ecoregion_adj <- factor(env$Ecoregion_adj, levels=c("Alboran Sea", "Western Mediterranean", "Central Mediterranean","Adriatic Sea","Aegean Sea","Levantine Sea")) # set levels order
eco <- env$Ecoregion_adj
bg <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3","#33a02c","#e31a1c") # 6 nice colors for our ecoregions_adj
# axes 1 & 2
# jpeg(filename = "RDAplot_mul2_enhanced.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3)
points(mul.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(mul.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[eco]) # the individuals
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(eco), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
load.rda <- scores(mul.rda, choices=c(1:2), display="species")  # Species scores for the first two constrained axes
hist(load.rda[,1], main="Loadings on RDA1")
hist(load.rda[,2], main="Loadings on RDA2")
outliers <- function(x,z){
lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading
x[x < lims[1] | x > lims[2]]               # locus names in these tails
}
cand1 <- outliers(load.rda[,1],3) # 642 candidate SNPs
cand2 <- outliers(load.rda[,2],3) # 122 candidate SNPs
ncand <- length(cand1) + length(cand2)
ncand # 764
# create dataframe with results
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
colnames(cand1) <- colnames(cand2) <- c("axis","snp","loading")
cand <- rbind(cand1, cand2)
cand$snp <- as.character(cand$snp)
# add in the correlations of each candidate SNP with the eight environmental predictors:
foo <- matrix(nrow=(ncand), ncol=4)  # 4 columns for 4 predictors
colnames(foo) <- c("lat","lon","SST", "SSS")
for (i in 1:length(cand$snp)) {
nam <- cand[i,2]
snp.gen <- mul.imp[,nam]
foo[i,] <- apply(pred,2,function(x) cor(x,snp.gen))
}
cand <- cbind.data.frame(cand,foo)
head(cand)
# look for duplicate candidates
length(cand$snp[duplicated(cand$snp)])  # 0 duplicate detections
# see which of the predictors each candidate SNP is most strongly correlated with:
for (i in 1:length(cand$snp)) {
bar <- cand[i,]
cand[i,8] <- names(which.max(abs(bar[4:7]))) # gives the variable
cand[i,9] <- max(abs(bar[4:7]))              # gives the correlation
}
colnames(cand)[8] <- "predictor"
colnames(cand)[9] <- "correlation"
table(cand$predictor)
# plot these highly correlated SNPs in the ordination space
sel <- cand$snp
envp <- cand$predictor
envp[envp=="lat"] <- '#1f78b4'
envp[envp=="lon"] <- '#a6cee3'
envp[envp=="SST"] <- '#6a3d9a'
envp[envp=="SSS"] <- '#e31a1c'
# color by predictor:
col.pred <- rownames(mul.rda$CCA$v) # pull the SNP names
for (i in 1:length(sel)) {           # color code candidate SNPs
foo <- match(sel[i],col.pred)
col.pred[foo] <- envp[i]
}
col.pred[grep("scaffold",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99','#b2df8a')
# plot the SNPs
# axes 1 & 2
plot(mul.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(mul.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(mul.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("bottomright", legend=c("lat","lon","SST", "SSS"), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
jpeg(filename = "RDAplot_mul_SNP.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(mul.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(mul.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("bottomright", legend=c("lat","lon","SST", "SSS"), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
dev.off()
setwd("/Users/eboulanger-admin/Documents/project_SEACONNECT/seaConnect--radFishComp/03-RDA/02-Mullus/a-all/")
# load packages
library(adegenet)
library(psych)
library(vegan)
# read in genetic data and extract minor allele frequency matrix
mullus_all <- read.PLINK("mullus_correctid.raw")
mul_m <-as.matrix(mullus_all)
# RDA requires complete data frames
sum(is.na(mul_m)) # 330 626 NA's in the matrix
# impute missing values using the most common genotype at each SNP across all individuals
mul.imp <- apply(mul_m, 2, function(x) replace(x, is.na(x), as.numeric(names(which.max(table(x))))))
sum(is.na(mul.imp)) # No NAs
# load environmental data
env <- read.table("../../00-envdata-EB/Mullus_yearly_SST_SSS.txt", sep = "\t", header = T, stringsAsFactors = F)
str(env)
env$Ecoregion <- as.factor(env$Ecoregion)
env$Ecoregion_adj <- as.factor(env$Ecoregion_adj)
# Confirm that genotypes and environmental data are in the same order
identical(rownames(mul.imp), env$ID) # FALSE
temp <- cbind(rownames(mul.imp), env$ID) # order is indeed different
rownames(env) <- env$ID
env <- env[rownames(mul.imp),]
identical(rownames(mul.imp), rownames(env)) #TRUE
View(env)
# dev.off()
# SST and SSS are highly correlated amongst eachother, of course, but only 60% between eachother -> ok for RDA
# keep only max of each for now
pred <- subset(env, select=c(lat, lon, SST_yearly_max, SSS_yearly_max, SST_april_mean, SSS_april_mean, bathy))
# load environmental data
env <- read.table("../../00-envdata-EB/Mullus_envData.txt", sep = "\t", header = T, stringsAsFactors = F)
str(env)
env$Ecoregion <- as.factor(env$Ecoregion)
env$Ecoregion_adj <- as.factor(env$Ecoregion_adj)
# Confirm that genotypes and environmental data are in the same order
identical(rownames(mul.imp), env$ID) # FALSE
temp <- cbind(rownames(mul.imp), env$ID) # order is indeed different
rownames(env) <- env$ID
env <- env[rownames(mul.imp),]
identical(rownames(mul.imp), rownames(env)) #TRUE
# dev.off()
# SST and SSS are highly correlated amongst eachother, of course, but only 60% between eachother -> ok for RDA
# keep only max of each for now
pred <- subset(env, select=c(lat, lon, SST_yearly_max, SSS_yearly_max, SST_april_mean, SSS_april_mean, bathy))
View(env)
# dev.off()
# SST and SSS are highly correlated amongst eachother, of course, but only 60% between eachother -> ok for RDA
# keep only max of each for now
pred <- subset(env, select=c(lat, lon, SST_yearly_max, SSS_yearly_max, SST_april_mean, SSS_april_mean, mean_bathy))
# dev.off()
# SST and SSS are highly correlated amongst eachother, of course, but only 60% between eachother -> ok for RDA
# keep only max of each for now
pred <- subset(env, select=c(lat, lon, SST_yearly_max, SSS_yearly_max, SST_april_mean, SSS_april_mean, mean_bat))
names(pred) <- c("lat", "lon","SST_yearly", "SSS_yearly", "SST_april","SSS_april", "bathy")
pairs.panels(pred, scale=T)
mul.rda <- rda(mul.imp ~ ., data=pred, scale=T)
mul.rda
# calculate adjusted Rsquared
RsquareAdj(mul.rda)
# $adj.r.squared
# [1] 0.00437503 -> very very low? 0,4% (wolf vignette: 5%)
# + lat + lon: 0.007944112
# eigenvalues constrained axes
summary(eigenvals(mul.rda, model = "constrained"))
screeplot(mul.rda)
# check RDA model for significance
# null-hypothesis: no linear relationship exists between SNP data and environmental predictors
Sys.time()
signif.full <- anova.cca(mul.rda, parallel=getOption("mc.cores")) # default is permutation=999
Sys.time()
signif.full
??dbmem
# axes 1 & 2
# jpeg(filename = "RDAplot_mul2_enhanced.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3)
points(mul.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(mul.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[eco]) # the individuals
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(eco), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
# more informative plot
#levels(env$Ecoregion_adj) <- c("Alboran Sea", "Western Mediterranean", "Central Mediterranean","Adriatic Sea","Aegean Sea","Levantine Sea")
#env$Ecoregion_adj <- factor(env$Ecoregion_adj, levels=c("Alboran Sea", "Western Mediterranean", "Central Mediterranean","Adriatic Sea","Aegean Sea","Levantine Sea")) # set levels order
eco <- env$Ecoregion_adj
bg <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3","#33a02c","#e31a1c") # 6 nice colors for our ecoregions_adj
jpeg(filename = "RDAplot_mul_all_3.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3)
points(mul.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(mul.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[eco]) # the individuals
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(eco), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
dev.off()
jpeg(filename = "mul_RDA_pred_corr_3.jpeg", res = 200, width = 1200, height = 1200)
pairs.panels(pred, scale=T)
dev.off()
load.rda <- scores(mul.rda, choices=c(1:2), display="species")  # Species scores for the first two constrained axes
hist(load.rda[,1], main="Loadings on RDA1")
hist(load.rda[,2], main="Loadings on RDA2")
outliers <- function(x,z){
lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading
x[x < lims[1] | x > lims[2]]               # locus names in these tails
}
cand1 <- outliers(load.rda[,1],3) # 642 candidate SNPs / 706
cand2 <- outliers(load.rda[,2],3) # 122 candidate SNPs / 229
ncand <- length(cand1) + length(cand2)
ncand # 764 / 935
# create dataframe with results
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
colnames(cand1) <- colnames(cand2) <- c("axis","snp","loading")
cand <- rbind(cand1, cand2)
cand$snp <- as.character(cand$snp)
# add in the correlations of each candidate SNP with the eight environmental predictors:
foo <- matrix(nrow=(ncand), ncol=7)  # 7 columns for 7 predictors
colnames(foo) <-  c("lat", "lon","SST_yearly", "SSS_yearly", "SST_april","SSS_april", "bathy")
for (i in 1:length(cand$snp)) {
nam <- cand[i,2]
snp.gen <- mul.imp[,nam]
foo[i,] <- apply(pred,2,function(x) cor(x,snp.gen))
}
cand <- cbind.data.frame(cand,foo)
head(cand)
# look for duplicate candidates
length(cand$snp[duplicated(cand$snp)])  # 0 / 15duplicate detections
View(cand)
# see which of the predictors each candidate SNP is most strongly correlated with:
for (i in 1:length(cand$snp)) {
bar <- cand[i,]
cand[i,11] <- names(which.max(abs(bar[4:10]))) # gives the variable
cand[i,12] <- max(abs(bar[4:10]))              # gives the correlation
}
colnames(cand)[8] <- "predictor"
colnames(cand)[9] <- "correlation"
table(cand$predictor)
# plot these highly correlated SNPs in the ordination space
sel <- cand$snp
envp <- cand$predictor
# plot these highly correlated SNPs in the ordination space
sel <- cand$snp
envp <- cand$predictor
envp[envp=="lat"] <- '#1f78b4'
envp[envp=="lon"] <- '#a6cee3'
envp[envp=="SST_yearly"] <- '#6a3d9a'
envp[envp=="SSS_yearly"] <- '#e31a1c'
envp[envp=="SST_april"] <- '#33a02c'
envp[envp=="SSS_april"] <- '#ffff33'
envp[envp=="bathy"] <- '#fb9a99'
# color by predictor:
col.pred <- rownames(mul.rda$CCA$v) # pull the SNP names
for (i in 1:length(sel)) {           # color code candidate SNPs
foo <- match(sel[i],col.pred)
col.pred[foo] <- envp[i]
}
col.pred[grep("scaffold",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99','#b2df8a')
# plot the SNPs
# axes 1 & 2
# jpeg(filename = "RDAplot_mul_SNP.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(mul.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
load.rda <- scores(mul.rda, choices=c(1:2), display="species")  # Species scores for the first two constrained axes
hist(load.rda[,1], main="Loadings on RDA1")
hist(load.rda[,2], main="Loadings on RDA2")
outliers <- function(x,z){
lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading
x[x < lims[1] | x > lims[2]]               # locus names in these tails
}
cand1 <- outliers(load.rda[,1],3) # 642 candidate SNPs / 706
cand2 <- outliers(load.rda[,2],3) # 122 candidate SNPs / 229
ncand <- length(cand1) + length(cand2)
ncand # 764 / 935
# create dataframe with results
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
colnames(cand1) <- colnames(cand2) <- c("axis","snp","loading")
cand <- rbind(cand1, cand2)
cand$snp <- as.character(cand$snp)
# add in the correlations of each candidate SNP with the eight environmental predictors:
foo <- matrix(nrow=(ncand), ncol=7)  # 7 columns for 7 predictors
colnames(foo) <-  c("lat", "lon","SST_yearly", "SSS_yearly", "SST_april","SSS_april", "bathy")
for (i in 1:length(cand$snp)) {
nam <- cand[i,2]
snp.gen <- mul.imp[,nam]
foo[i,] <- apply(pred,2,function(x) cor(x,snp.gen))
}
cand <- cbind.data.frame(cand,foo)
head(cand)
# look for duplicate candidates
length(cand$snp[duplicated(cand$snp)])  # 0 / 15duplicate detections
# see which of the predictors each candidate SNP is most strongly correlated with:
for (i in 1:length(cand$snp)) {
bar <- cand[i,]
cand[i,11] <- names(which.max(abs(bar[4:10]))) # gives the variable
cand[i,12] <- max(abs(bar[4:10]))              # gives the correlation
}
colnames(cand)[11] <- "predictor"
colnames(cand)[12] <- "correlation"
table(cand$predictor)
# plot these highly correlated SNPs in the ordination space
sel <- cand$snp
envp <- cand$predictor
envp[envp=="lat"] <- '#1f78b4'
envp[envp=="lon"] <- '#a6cee3'
envp[envp=="SST_yearly"] <- '#6a3d9a'
envp[envp=="SSS_yearly"] <- '#e31a1c'
envp[envp=="SST_april"] <- '#33a02c'
envp[envp=="SSS_april"] <- '#ffff33'
envp[envp=="bathy"] <- '#fb9a99'
# color by predictor:
col.pred <- rownames(mul.rda$CCA$v) # pull the SNP names
for (i in 1:length(sel)) {           # color code candidate SNPs
foo <- match(sel[i],col.pred)
col.pred[foo] <- envp[i]
}
col.pred[grep("scaffold",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99','#b2df8a')
# plot the SNPs
# axes 1 & 2
# jpeg(filename = "RDAplot_mul_SNP.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(mul.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(mul.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("bottomright", legend=c("lat","lon","SST", "SSS"), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
legend("bottomleft", legend=c("lat", "lon","SST_yearly", "SSS_yearly", "SST_april","SSS_april", "bathy"),
bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
jpeg(filename = "RDAplot_mul_SNP_3.jpeg", res = 200, width = 1200, height = 1200)
plot(mul.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(mul.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(mul.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(mul.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("bottomleft", legend=c("lat", "lon","SST_yearly", "SSS_yearly", "SST_april","SSS_april", "bathy"),
bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
# dev.off()
dev.off()
setwd("/Users/eboulanger-admin/Documents/project_SEACONNECT/seaConnect--radFishComp/03-RDA/01-Diplodus/c-adaptive/")
# read in genetic data and extract minor allele frequency matrix
diplodus_all <- read.PLINK("diplodus_adaptive.raw")
